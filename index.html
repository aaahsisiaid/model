<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Head Tracking 3D Viewer (ESM)</title>
<style>
html, body {
  margin: 0;
  overflow: hidden;
  background: #000;
}
#video {
  position: fixed;
  right: 10px;
  bottom: 10px;
  width: 160px;
  opacity: 0.25;
  z-index: 10;
}
canvas {
  display: block;
}
</style>
</head>
<body>

<video id="video" autoplay muted playsinline></video>

<script type="module">
/* =========================
   import
========================= */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

import { FaceMesh } from "https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js";
import { Camera } from "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

/* =========================
   Three.js 初期化
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.01,
  100
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Light
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 5, 5);
scene.add(dirLight);

// Model
let model = null;
const loader = new GLTFLoader();
loader.load("./model.glb", (gltf) => {
  model = gltf.scene;
  model.scale.set(1, 1, 1);
  scene.add(model);
});

// 初期カメラ
camera.position.set(0, 0, 5);

/* =========================
   FaceMesh
========================= */
const video = document.getElementById("video");

const faceMesh = new FaceMesh({
  locateFile: (file) =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
});

faceMesh.setOptions({
  maxNumFaces: 1,
  refineLandmarks: true,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7,
});

// ランドマークID
const LEFT_EYE = 33;
const RIGHT_EYE = 263;

// target / filtered
let tx = 0, ty = 0, tz = 5;
let fx = 0, fy = 0, fz = 5;

faceMesh.onResults((res) => {
  if (!res.multiFaceLandmarks) return;

  const lm = res.multiFaceLandmarks[0];
  const le = lm[LEFT_EYE];
  const re = lm[RIGHT_EYE];

  // 顔中心（-0.5～0.5）
  const cx = (le.x + re.x) / 2 - 0.5;
  const cy = (le.y + re.y) / 2 - 0.5;

  // 両目距離 → 奥行き
  const dx = le.x - re.x;
  const dy = le.y - re.y;
  const eyeDist = Math.sqrt(dx * dx + dy * dy);

  // 目標カメラ座標
  tx = cx * 3.0;
  ty = -cy * 2.0;
  tz = THREE.MathUtils.clamp(0.06 / eyeDist, 2.5, 8.0);
});

/* =========================
   Animation
========================= */
function animate() {
  requestAnimationFrame(animate);

  // スムージング（重要）
  fx += (tx - fx) * 0.08;
  fy += (ty - fy) * 0.08;
  fz += (tz - fz) * 0.08;

  camera.position.set(fx, fy, fz);
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}
animate();

/* =========================
   Camera start
========================= */
const cam = new Camera(video, {
  onFrame: async () => {
    await faceMesh.send({ image: video });
  },
  width: 640,
  height: 480,
});
cam.start();

/* =========================
   Resize
========================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
